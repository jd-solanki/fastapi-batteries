{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>FastAPI Batteries is a collection of tools and utilities to help you build FastAPI applications faster.</p>"},{"location":"#why","title":"Why?","text":"<p>In my every FastAPI project I use the same tech stack, tools and utilities. So I decided to create a package that includes all of them.</p> <p>Here's my tech stack:</p> <ul> <li>FastAPI</li> <li>Pydantic</li> <li>Pydantic Settings</li> <li>SQLAlchemy 2.x w/ Declarative Syntax (Async via <code>asyncpg</code>)</li> <li>Alembic</li> <li>Postgres</li> </ul> <p>This package is opinionated and it's built around my tech stack. As it evolves we might add more tools and utilities and make it generic enough to be used in any FastAPI project.</p>"},{"location":"crud/","title":"CRUD","text":"<p>FastAPI batteries comes with CRUD helper that uses async SQLAlchemy to perform CRUD operations.</p>"},{"location":"crud/#usage","title":"Usage","text":"<p>\ud83d\udea7 TBD. Implementation is almost completed so you can check source code here and example here</p>"},{"location":"installation/","title":"Installation","text":"<p>FastAPI Batteries is available on PyPI as fastapi-batteries so installation is as simple as:</p> uvpip <pre><code>uv add fastapi-batteries\n</code></pre> <pre><code>pip install fastapi-batteries\n</code></pre> <p>You're good to go now.</p>"},{"location":"alembic/utils/","title":"Utils","text":"<p>Along with SQLAlchemy you've probably used the Alembic for migrations.</p>"},{"location":"alembic/utils/#import_models","title":"<code>import_models</code>","text":"<p>This function is used to import all models from the given module. Typically used in <code>alembic/env.py</code> file where you need to import all models to generate migrations.</p> alembic/env.py<pre><code>from fastapi_batteries.alembic.utils import import_models\n\n# Rest of the code\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\nimport_models() \ntarget_metadata = Base.metadata\n</code></pre> <p>This is also useful if you have some other environments like celery where sometimes you might need to import models.</p> <pre><code>from fastapi_batteries.alembic.utils import import_models\n\nimport_models() \n\ncelery_app = Celery(\n    # Your celery config\n)\n</code></pre>"},{"location":"fastapi/dependencies/","title":"Dependencies","text":"<p>FastAPI Batteries comes with some handful dependencies that are common in most FastAPI projects.</p>"},{"location":"fastapi/dependencies/#file-validator","title":"File Validator","text":"<p>This dependency uses python-magic to accurately determine the file type of the uploaded file.</p> <p>You can use this validator to:</p> <ul> <li>Validate the file type (via mime type)</li> <li>Validate File Size</li> </ul> ExamplePreview <pre><code>from typing import Annotated\n\nfrom fastapi import Depends, FastAPI, UploadFile\n\nfrom fastapi_batteries.fastapi.deps import FileValidator\nfrom fastapi_batteries.utils.size import mb_to_bytes\n\napp = FastAPI()\n\n\nimg_validator_upto_1mb = FileValidator(\n    max_size_bytes=mb_to_bytes(1),\n    allowed_mime_types=[\"image/jpeg\", \"image/png\", \"image/svg+xml\", \"image/webp\"],\n)\n\npdf_validator_upto_5mb = FileValidator(max_size_bytes=mb_to_bytes(5), allowed_mime_types=[\"application/pdf\"])\n\n\n@app.post(\"/upload/\")\nasync def upload_file(file: Annotated[UploadFile, Depends(img_validator_upto_1mb)]): ...\n</code></pre> <p></p>"},{"location":"fastapi/dependencies/#pagination-query-params","title":"Pagination Query Params","text":"<p>FastAPI allows using Pydantic model as query parameter model.</p> <p>Thanks to that you can have reusable pagination query parameters. This is minimal but faster and when you pair it with our CRUD helper it becomes more powerful.</p> ExamplePreview <pre><code>from typing import Annotated\n\nfrom fastapi import FastAPI, Query\n\nfrom fastapi_batteries.pydantic.schemas import PaginationOffsetLimit, PaginationPageSize\n\napp = FastAPI()\n\n\n@app.get(\"/items/\")\nasync def get_items_page_size_pagination(pagination: Annotated[PaginationPageSize, Query()]):\n    return pagination\n\n\n@app.get(\"/products/\")\nasync def get_products_offset_limit_pagination(pagination: Annotated[PaginationOffsetLimit, Query()]):\n    return pagination\n</code></pre> <p></p>"},{"location":"fastapi/dependencies/#using-with-other-query-params","title":"Using with other query params","text":"<p>When you use Pydantic model schema along with other query params you'll get Pydantic model schema in request body which is wrong:</p> ExamplePreview <pre><code>from typing import Annotated\n\nfrom fastapi import FastAPI, Query\n\nfrom fastapi_batteries.pydantic.schemas import PaginationPageSize\n\napp = FastAPI()\n\n\n@app.get(\"/items/\")\nasync def get_items_page_size_pagination(\n    pagination: Annotated[PaginationPageSize, Query()],\n    q: str = \"\",\n):\n    return {\"q\": q, \"pagination\": pagination}\n</code></pre> <p></p> <p>This is limitation (or bug) from FastAPI. There's already open issue and related discussions for this. However, we've nice workaround for this.</p> <p>We just have to replace <code>Query()</code> with <code>Depends()</code> and it'll work as expected:</p> <pre><code>- pagination: Annotated[PaginationPageSize, Query()],\n+ pagination: Annotated[PaginationPageSize, Depends()],\n</code></pre> ExamplePreview <pre><code>from typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\nfrom fastapi_batteries.pydantic.schemas import PaginationPageSize\n\napp = FastAPI()\n\n\n@app.get(\"/items/\")\nasync def get_items_page_size_pagination(\n    pagination: Annotated[PaginationPageSize, Depends()],\n    q: str = \"\",\n):\n    return {\"q\": q, \"pagination\": pagination}\n</code></pre> <p></p>"},{"location":"fastapi/exceptions/","title":"Exceptions","text":""},{"location":"fastapi/exceptions/#apiexception","title":"APIException","text":"<p>Raising exception with useful error message is a good practice and there's RFC 9457 that suggests how to do it. FastAPI has this on its roadmap however it's not implemented yet.</p> <p>FastAPI batteries custom exception class <code>APIException</code> that can be used to raise exceptions following RFC 9457.</p> ExamplePreview <pre><code>from fastapi import FastAPI, status\n\nfrom fastapi_batteries.fastapi.exceptions import APIException, get_api_exception_handler\n\napp = FastAPI()\n\napp.add_exception_handler(APIException, get_api_exception_handler())\n\n\n@app.get(\"/raises-exception/\")\nasync def get_index():\n    raise APIException(\n        status=status.HTTP_400_BAD_REQUEST,\n        title=\"This is a test exception.\",\n    )\n</code></pre> <p></p> <p>Right now, It only handles <code>APIException</code> and convert to RFC 9457 compliant response. I'm planning to also handle Pydantic's validation error and convert to RFC 9457 compliant response. If you have any other suggestions, please let me know.</p>"},{"location":"fastapi/middlewares/","title":"Middlewares","text":"<p>FastAPI (and starlette) already provides some useful middlewares however along with that I prefer some custom solution that can be used with my tech stack.</p>"},{"location":"fastapi/middlewares/#sqlalchemy-query-count","title":"SQLAlchemy Query Count","text":"<p>This middleware returns total number of queries executed for each request via response header <code>X-DB-Query-Count</code>.</p> ExamplePreview <pre><code>from fastapi import FastAPI\nfrom sqlalchemy import text\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nfrom fastapi_batteries.fastapi.middlewares import QueryCountMiddleware\n\napp = FastAPI()\n\n\nengine = create_async_engine(\"sqlite+aiosqlite:///:memory:\", echo=False)\n\n\napp.add_middleware(QueryCountMiddleware, engine=engine)\n\n\n@app.get(\"/\")\nasync def get_index():\n    async with engine.connect() as conn:\n        await conn.execute(text(\"SELECT 1\"))\n        await conn.commit()\n\n        return {\"message\": \"Hello World\"}\n</code></pre> <p></p>"},{"location":"fastapi/middlewares/#request-process-time","title":"Request Process Time","text":"<p>This middleware returns execution time of each request via response header <code>X-Process-Time</code>.</p> ExamplePreview <pre><code>from fastapi import FastAPI\n\nfrom fastapi_batteries.fastapi.middlewares import RequestProcessTimeMiddleware\n\napp = FastAPI()\n\napp.add_middleware(RequestProcessTimeMiddleware)\n\n\n@app.get(\"/\")\nasync def get_index():\n    return {\"message\": \"Hello World\"}\n</code></pre> <p></p>"},{"location":"fastapi/utils/","title":"Utils","text":"<p>We've added bunch of utilities to help you build the FastAPI project faster.</p>"},{"location":"fastapi/utils/#use_route_path_as_operation_ids","title":"<code>use_route_path_as_operation_ids</code>","text":"<p>This utility won't speed up your development but instead it will ease life of frontend developer (or you if you're full stack developer) using your OpenAPI specs via generate clients (or SDK). By default, FastAPI generates operation ids automatically.</p> <p>For example, You generated TypeScript types from OpenAPI specs and you'll use type like this: <code>type FRONTEND_TYPE = APIResponse&lt;'your_operation_id', 200&gt;</code>. Here, <code>APIResponse</code> is TypeScript's utility type that extract actual response type for given status code (in this case <code>200</code>). Thanks to this, Whenever you change response schema in FastAPI your frontend will be aware of new schema without manually writing any code.</p> <p>I really like this linked schemas as this allows safety while writing frontend code which is completely decoupled from backend. Fun Fact, I fixed bug without running actual frontend &amp; backend servers thanks to this linked schemas and guess what it resolved bug in production successfully. Kinda risky but I'm proud of it and tell this to everyone including you know \ud83d\ude09</p> <p></p> <p>Here's the default behavior.</p> <pre><code>@app.get(\"/\")\ndef get_index():\n    return {\"Hello\": \"World\"}\n</code></pre> <p>For above operation, FastAPI will generate <code>get_index__get</code> as operation id. However, frontend developer won't know that <code>/</code> (root or index) API endpoint's operation id is <code>get_index__get</code> without looking at the source code and knowing the convention (<code>FUNC_NAME</code> + <code>__</code> + <code>HTTP_METHOD</code> most probably).</p> <p>This utility function will help you generate predictable operation id because it generates id based on route path which frontend (or you if you're full stack) dev already knows.</p> <p>For the same operation above, <code>use_route_path_as_operation_ids</code> will generate <code>get_</code> as operation id.</p> <p>Here's convention: <code>HTTP_METHOD</code> + <code>_</code> + <code>ROUTE_PATH</code> (+ <code>__PARAM__</code> if path has parameter)</p> <pre><code>from fastapi import FastAPI\n\nfrom fastapi_batteries.fastapi.utils import use_route_path_as_operation_ids\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def get_index():\n    return {\"operation id\": \"get\"}\n\n\n@app.post(\"/items\")\nasync def post_items():\n    return {\"operation id\": \"post_items\"}\n\n\n@app.get(\"/items\")\nasync def get_items():\n    return {\"operation id\": \"get_items\"}\n\n\n@app.get(\"/items/{item_id}\")\nasync def get_item():\n    return {\"operation id\": \"get_items__item_id\"}\n\n\n@app.get(\"/items/{item_id}/sub_item\")\nasync def get_item_subitem():\n    return {\"operation id\": \"get_items__item_id__sub_item\"}\n\n\nuse_route_path_as_operation_ids(app)\n</code></pre> <p>Warning</p> <p>Ensure, You always use this util after defining or including all of your operations (This is also stated in official FastAPI docs).</p> <p>Additionally, <code>use_route_path_as_operation_ids</code> also allows you to enforce the function name to be same as generated operation ID via <code>warn_on_func_name_mismatch</code> parameter. This is useful when you want to ensure that your operation ID is same as function name.</p> <pre><code>from fastapi import FastAPI\n\nfrom fastapi_batteries.fastapi.utils import use_route_path_as_operation_ids\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def get_index():\n    return {\"message\": \"Hello World\"}\n\n\nuse_route_path_as_operation_ids(app, warn_on_func_name_mismatch=True)\n</code></pre> <p>For the given example, Running the app will raise a warning:</p> <pre><code>UserWarning: Route \"/\" has the function name \"get_index\" which does not match expected operation ID: \"get\"\n</code></pre>"},{"location":"pydantic/schemas/","title":"Schemas","text":"<p>FastAPI Batteries also provides reusable schemas which you can reuse across all of your projects.</p>"},{"location":"pydantic/schemas/#pagination","title":"Pagination","text":"<p>This schemas are already covered in FastAPI's dependency section.</p> <p>more to come...</p>"},{"location":"sqlalchemy/mixins/","title":"Mixins","text":"<p>You might have created some mixins which you use through out the project and also across multiple projects.</p> <p>Here are some common mixins which you can reuse without building your own along with feature to rename column names.</p> <p>Note</p> <p>All mixins inherit from <code>MappedAsDataclass</code> to get maximum type hints while using SQLAlchemy 2.x</p> <p>If you don't know what is <code>MappedAsDataclass</code>, This is similar to adding type hints features of SQLModel to our regular SQLAlchemy</p> <p>All of the mixins are self explanatory so here's list of all:</p> <ul> <li><code>MixinId</code></li> <li><code>MixinCreatedAt</code></li> <li><code>MixinUpdatedAt</code></li> <li><code>MixinIsDeleted</code></li> </ul> <p>Using all of the mixin is straight forward so here's minimal example for all of them:</p> <pre><code>from fastapi_battries.sa.mixins import MixinId\n\nclass Product(Base, MixinId):\n    __tablename__ = \"product\"\n\n    title: Mapped[str]\n</code></pre> <p>You can view source code of all mixins here.</p>"},{"location":"sqlalchemy/mixins/#mixinfactory","title":"<code>MixinFactory</code>","text":"<p>Sometime, You might want renamed column for example when using <code>MixinUpdatedAt</code> you'll get <code>updated_at</code> column but you want column name as <code>last_modified_at</code> or <code>started_at</code> to make it more meaningful according to your model. For this, <code>MixinFactory</code> allows you to generate renamed column from existing mixins.</p> <pre><code>from fastapi_batteries.sa.mixins import MixinFactory, MixinId, MixinCreatedAt\n\nMixinStartedAt = MixinFactory.get_renamed(MixinCreatedAt, \"started_at\")\n\nclass Workflow(Base, MixinId, MixinStartedAt):\n    __tablename__ = \"workflow\"\n\n    title: Mapped[str]\n</code></pre> <p>As this is just utility you can also use it on your own mixins.</p> <pre><code>from fastapi_batteries.sa.mixins import MixinFactory\n\nclass YourMixin(Base):\n    your_col_name: Mapped[str]\n\nRenamedMixin = MixinFactory.get_renamed(YourMixin, \"new_col_name\")\n\nclass Workflow(Base, RenamedMixin): ...\n</code></pre>"}]}